# -*- coding: utf-8 -*-
"""4107_data exploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CI13WlBu-W3Qf3eJwY0oIVxMEkr2v2qH
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.regression.linear_model import OLS
import statsmodels.api as sm

# Load data
df = pd.read_csv('AMD.csv', parse_dates=['Date'], index_col='Date')

# 1. Data preprocessing
# Calculate log returns
df['log_return'] = np.log(df['Close']).diff()
df = df.dropna()

# 2. Descriptive statistics
stats = df['log_return'].describe()
stats['skewness'] = df['log_return'].skew()
stats['kurtosis'] = df['log_return'].kurtosis()
print("Descriptive Statistics:\n", stats)

# 3. Graphical analysis
# 3.1 Price and return plots
plt.figure(figsize=(12, 10))
plt.subplot(3, 1, 1)
plt.plot(df.index, df['Close'])
plt.title('AMD Stock Price')
plt.ylabel('Price')

plt.subplot(3, 1, 2)
plt.plot(df.index, np.log(df['Close']))
plt.title('AMD Log Price')
plt.ylabel('Log Price')

plt.subplot(3, 1, 3)
plt.plot(df.index, df['log_return'])
plt.title('AMD Log Returns')
plt.ylabel('Log Return')

plt.tight_layout()
plt.savefig('amd_series_comparison.png')
plt.show()

# 3.2 Return distribution
plt.figure(figsize=(10, 6))
df['log_return'].hist(bins=50, density=True, alpha=0.6, color='g')

mu = df['log_return'].mean()
sigma = df['log_return'].std()
x = np.linspace(mu - 4*sigma, mu + 4*sigma, 100)
plt.plot(x, 1/(sigma * np.sqrt(2 * np.pi)) * np.exp(-(x - mu)**2 / (2 * sigma**2)), 'r-', lw=2)

plt.title('AMD Log Return Distribution')
plt.xlabel('Log Return')
plt.ylabel('Frequency')
plt.legend(['Normal Distribution', 'Actual Distribution'])
plt.savefig('amd_return_distribution.png')
plt.show()

# 3.3 Autocorrelation analysis
fig, axes = plt.subplots(2, 2, figsize=(15, 8))
plot_acf(df['log_return'], lags=20, ax=axes[0, 0])
axes[0, 0].set_title('ACF of Log Returns')

plot_pacf(df['log_return'], lags=20, ax=axes[0, 1])
axes[0, 1].set_title('PACF of Log Returns')

plot_acf(df['log_return']**2, lags=20, ax=axes[1, 0])
axes[1, 0].set_title('ACF of Squared Log Returns')

plot_pacf(df['log_return']**2, lags=20, ax=axes[1, 1])
axes[1, 1].set_title('PACF of Squared Log Returns')

plt.tight_layout()
plt.savefig('amd_acf_pacf.png')
plt.show()

# 4. Statistical tests
# 4.1 ADF test
def perform_adf_test(series, title):
    result = adfuller(series.dropna())
    print(f'===== ADF Test Results for {title} =====')
    print(f'ADF Statistic: {result[0]}')
    print(f'p-value: {result[1]}')
    print(f'Critical Values:')
    for key, value in result[4].items():
        print(f'\t{key}: {value}')

    if result[1] <= 0.05:
        print("Conclusion: Reject null hypothesis, series is stationary")
    else:
        print("Conclusion: Fail to reject null hypothesis, series is non-stationary")
    print("\n")

# 4.2 KPSS test
def perform_kpss_test(series, title):
    result = kpss(series.dropna())
    print(f'===== KPSS Test Results for {title} =====')
    print(f'KPSS Statistic: {result[0]}')
    print(f'p-value: {result[1]}')
    print(f'Critical Values:')
    for key, value in result[3].items():
        print(f'\t{key}: {value}')

    if result[1] <= 0.05:
        print("Conclusion: Reject null hypothesis, series is non-stationary")
    else:
        print("Conclusion: Fail to reject null hypothesis, series is stationary")
    print("\n")

# Perform tests
perform_adf_test(df['Close'], 'Original Price')
perform_adf_test(np.log(df['Close']), 'Log Price')
perform_adf_test(df['log_return'], 'Log Returns')

perform_kpss_test(df['Close'], 'Original Price')
perform_kpss_test(np.log(df['Close']), 'Log Price')
perform_kpss_test(df['log_return'], 'Log Returns')

# 5. Volatility characteristics
# 5.1 Calculate rolling volatility
df['rolling_vol'] = df['log_return'].rolling(window=20).std() * np.sqrt(252)  # Annualized

# 5.2 Plot rolling volatility
plt.figure(figsize=(12, 6))
plt.plot(df.index, df['rolling_vol'])
plt.title('AMD 20-Day Rolling Volatility (Annualized)')
plt.ylabel('Volatility')
plt.grid(True)
plt.savefig('amd_rolling_volatility.png')
plt.show()

# 5.3 Test volatility mean reversion
vol_data = df['rolling_vol'].dropna()
lagged_vol = vol_data.shift(1).dropna()
vol_data = vol_data[1:]  # Align data

X = sm.add_constant(lagged_vol)
model = OLS(vol_data, X).fit()

print("Volatility Mean Reversion Test Results:")
print(model.summary())

# 6. Summary of results
print("\n==== Stationarity Test Summary ====")
print("1. Original price series: Expected non-stationary")
print("2. Log price series: Expected non-stationary")
print("3. Log return series: Expected stationary")

print("\n==== Volatility Characteristics Summary ====")
print(f"1. Return kurtosis: {stats['kurtosis']:.4f} (Normal distribution is 3)")
print("2. Volatility clustering: Based on ACF of squared returns")
print("3. Mean reversion: Based on regression model coefficients")

print("\n==== Modeling Recommendations ====")
print("1. If returns are stationary with volatility clustering, GARCH models are recommended")
print("2. If return distribution shows asymmetry, consider asymmetric GARCH models")
print("3. If volatility exhibits mean reversion, GARCH models should capture this feature effectively")